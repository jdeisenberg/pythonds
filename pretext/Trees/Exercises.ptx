<?xml version="1.0" encoding="UTF-8"?>
<section xml:id="trees_exercises">
  <title>Trees: Exercises</title>
  <exercises>
			<exercise><p>Draw the tree structure resulting from the following set of tree
                    function calls:</p>
                <pre>
       >>> r = BinaryTree(3)
       >>> insert_left(r, 4)
       [3, [4, [], []], []]
       >>> insert_left(r, 5)
       [3, [5, [4, [], []], []], []]
       >>> insert_right(r, 6)
       [3, [5, [4, [], []], []], [6, [], []]]
       >>> insert_right(r, 7)
       [3, [5, [4, [], []], []], [7, [], [6, [], []]]]
       >>> set_root_val(r, 9)
       >>> insert_left(r, 11)
       [9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]]
	      </pre></exercise>

			<exercise><p>Trace the algorithm for creating an expression tree for the
                    expression <m>(4 * 8) / 6 - 3</m>.</p></exercise>

			<exercise><p>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show
   the binary search tree resulting from inserting the integers in the
   list.</p></exercise>

			<exercise><p>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show
   the binary search tree resulting from inserting the integers in the
   list.</p></exercise>

			<exercise><p>Generate a random list of integers. Show the binary heap tree
   resulting from inserting the integers on the list one at a time.</p></exercise>

			<exercise><p>Using the list from the previous question, show the binary heap tree
   resulting from using the list as a parameter to the <c>heapify</c>
   method. Show both the tree and list form.</p></exercise>

			<exercise><p>Draw the binary search tree that results from inserting the following
   keys in the order given: 68, 88, 61, 89, 94, 50, 4, 76, 66, and 82.</p></exercise>

			<exercise><p>Generate a random list of integers. Draw the binary search tree
   resulting from inserting the integers on the list.</p></exercise>

			<exercise><p>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show
   the binary heap resulting from inserting the integers one at a time.</p></exercise>

			<exercise><p>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show
   the binary heap resulting from inserting the integers one at a time.</p></exercise>

			<exercise><p>Consider the two different techniques we used for implementing traversals of a binary
   tree. Why must we check before the call to <c>preorder</c> when
   implementing it as a method, whereas we could check inside the call when
   implementing it as a function?</p></exercise>

   <exercise><p>Show the function calls needed to build the following binary tree.</p>
<figure align="center" xml:id="fig-tree-languages">
    <!--<caption>????</caption>-->
      <image source="Trees/Figures/exerTree.png" width="50%" alt="tree showing computer languages as nodes"/>
    </figure>
</exercise>


			<exercise><p>Given the following tree, perform the appropriate rotations to bring it back into balance.
                    <figure align="center" xml:id="fig-tree-rotations">
                        <image source="Trees/Figures/rotexer1.png" width="25%" alt="unbalanced tree"/>
                        </figure>
            </p></exercise>

			<exercise><p>Using the following as a starting point, derive the equation that gives the updated balance factor for node D.
                    <figure align="center" xml:id="fig-tree-balance-factor">
                        <image source="Trees/Figures/bfderive.png" width="50%" alt="diagram showing tree before and after; in after diagram, node D is at root"/>
                        </figure>
                    </p></exercise>

			<exercise><p>Extend the <c>build_parse_tree</c> function to handle mathematical
   expressions that do not have spaces between every character.</p></exercise>

			<exercise><p>Modify the <c>build_parse_tree</c> and <c>evaluate</c> functions to handle
   Boolean statements (<c>and</c>, <c>or</c>, and <c>not</c>). Remember that <c>not</c> is a unary
   operator, so this will complicate your code somewhat.</p></exercise>

			<exercise><p>Using the <c>find_successor</c> method, write a non-recursive inorder
   traversal for a binary search tree.</p></exercise>

   <exercise><p>A <em>threaded</em> binary tree maintains a reference from each node to
   its successor. Modify the code for a binary search tree to make it threaded, then
   write a non-recursive inorder traversal method for the threaded binary search
   tree.</p></exercise>

			<exercise><p>Modify our implementation of the binary search tree so that it
   handles duplicate keys properly. That is, if a key is already in the
   tree then the new payload should replace the old rather than add
   another node with the same key.</p></exercise>

			<exercise><p>Create a binary heap with a limited heap size. In other words, the
   heap only keeps track of the <m>n</m> most important items. If the heap
   grows in size to more than <m>n</m> items the least important item is
   dropped.</p></exercise>

			<exercise><p>Clean up the <c>print_exp</c> function so that it does not include an
   extra set of parentheses around each number.</p></exercise>

			<exercise><p>Using the <c>heapify</c> method, write a sorting function that can
   sort a list in <m>O(n\log{n})</m> time.</p></exercise>

			<exercise><p>Write a function that takes a parse tree for a mathematical
   expression and calculates the derivative of the expression with
   respect to some variable.</p></exercise>

			<exercise><p>Implement a binary heap as a max heap.</p></exercise>

			<exercise><p>Using the <c>BinaryHeap</c> class, implement a new class called
   <c>PriorityQueue</c>. Your <c>PriorityQueue</c> class should implement the
   constructor plus the <c>enqueue</c> and <c>dequeue</c> methods.</p></exercise>

   <exercise><p>Implement the <c>delete</c> method for an AVL tree.</p></exercise>


</exercises>
</section>

